#!/usr/bin/env python3

# ----------------------------------------------------------------------------
#                Copyright (C) 2019 The PSMILU AUTHORS
# ----------------------------------------------------------------------------
"""Script tool to convert a MATLAB sparse matrix to PSMILU native binary format
"""

import sys

import scipy.io as sio
import numpy as np

IS_LITTLE = 1 if sys.byteorder == 'little' else 0
WORD_SIZE = 8 if sys.maxsize > 2**32 else 4
DOUBLE = np.dtype('float64')
SINGLE = np.dtype('float32')
ZCMPLX = np.dtype(np.complex128)


def is_real(d):
    return 1 if d == DOUBLE or d == SINGLE else 0


def is_double(d):
    return 1 if d == DOUBLE or d == ZCMPLX else 0


def get_parser():
    import argparse

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument(
        '-i',
        '--input',
        type=str,
        required=True,
        help='arg of [MATLAB mat file]:[sparse matrix name] pair')
    parser.add_argument(
        '-c',
        '--ccs',
        action='store_true',
        help='Out put CCS storage if specified, default is CRS')
    parser.add_argument(
        '-m',
        '--symm_size',
        type=int,
        help='Leading block size, default is 0 (asymmetric system)',
        default=0)
    parser.add_argument(
        '--determine_symm_size',
        action='store_true',
        help='If specified, then will try to determine the leading block OTF')
    return parser


def write_psmilu(f, info, sizes, *data_attrs):
    info.tofile(f)
    sizes.tofile(f)
    for i in range(3):
        data_attrs[i].tofile(f)


def main(argv=None):
    args = get_parser().parse_args(argv[1:])
    fname, sp_key = args.input.split(':')
    if not fname.endswith('.mat'):
        fname += '.mat'
    if sp_key == '':
        raise ValueError('Invalid MATLAB file input')
    fbase = fname[:fname.rfind('.')]
    is_row = 1 if not args.ccs else 0
    m_sparse = sio.loadmat(fname)[sp_key]
    int_size = m_sparse.indptr.dtype.alignment
    real_dtype = m_sparse.data.dtype
    is_d = is_double(real_dtype)
    is_r = is_real(real_dtype)
    gen_info = np.asarray(
        [IS_LITTLE, WORD_SIZE, int_size, is_row, 1, is_d, is_r], dtype='int8')
    mat_sizes = np.asarray(
        [m_sparse.shape[0], m_sparse.shape[1], m_sparse.nnz, args.symm_size],
        dtype='uint64')
    # m_sparse is CCS
    if not args.determine_symm_size:
        if args.symm_size < 0:
            raise ValueError('Negative leading block size')
        if not args.ccs:
            m_crs = m_sparse.tocsr()
            indptr = m_crs.indptr
            indices = m_crs.indices
            vals = m_crs.data
        else:
            indptr = m_sparse.indptr
            indices = m_sparse.indices
            vals = m_sparse.data
        f = open(fbase + '.psmilu', 'wb')
        write_psmilu(f, gen_info, mat_sizes, indptr, indices, vals)
        f.close()
    else:
        raise NotImplementedError


if __name__ == '__main__':
    sys.exit(main(sys.argv))
