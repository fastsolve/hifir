<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HIFIR: hif::Crout Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HIFIR
   &#160;<span id="projectnumber">0.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classhif_1_1Crout.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classhif_1_1Crout-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hif::Crout Class Reference<div class="ingroups"><a class="el" href="group__alg.html">Algorithms</a> &raquo; <a class="el" href="group__crout.html">Crout Update</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> update in deferred fashionThe idea of this class is to implement <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> kernels that wrap around a common factor&mdash;step. In this case, the class <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> is as simple (in terms of data size) as an integer. It also supports implicitly casting to integer as well as increment operations (both suffix and prefix versions). The whole disign can be demonstrate by the following C++ pseudocode:  
 <a href="classhif_1_1Crout.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89a81b5f9cfd0ad38ce4021f4aaf8a4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a89a81b5f9cfd0ad38ce4021f4aaf8a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">size type  <a href="#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">More...</a><br /></td></tr>
<tr class="separator:a89a81b5f9cfd0ad38ce4021f4aaf8a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d4ddd7a6707f318b734410ec419c948"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a7d4ddd7a6707f318b734410ec419c948">Crout</a> ()</td></tr>
<tr class="memdesc:a7d4ddd7a6707f318b734410ec419c948"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#a7d4ddd7a6707f318b734410ec419c948">More...</a><br /></td></tr>
<tr class="separator:a7d4ddd7a6707f318b734410ec419c948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd72ad4d40f88860101746811ce3176"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a5dd72ad4d40f88860101746811ce3176">Crout</a> (const <a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;)=default</td></tr>
<tr class="separator:a5dd72ad4d40f88860101746811ce3176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b517a206e7b25fb510cc6565e18706f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a5b517a206e7b25fb510cc6565e18706f">operator=</a> (const <a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;)=default</td></tr>
<tr class="separator:a5b517a206e7b25fb510cc6565e18706f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e22ec45a6def489e94b478f999654c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a5e22ec45a6def489e94b478f999654c4">operator=</a> (const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> step)</td></tr>
<tr class="memdesc:a5e22ec45a6def489e94b478f999654c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign to a step  <a href="#a5e22ec45a6def489e94b478f999654c4">More...</a><br /></td></tr>
<tr class="separator:a5e22ec45a6def489e94b478f999654c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6b19fcecbd3a053016d8bc7a5b0c56"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a8c6b19fcecbd3a053016d8bc7a5b0c56">operator++</a> ()</td></tr>
<tr class="memdesc:a8c6b19fcecbd3a053016d8bc7a5b0c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> step  <a href="#a8c6b19fcecbd3a053016d8bc7a5b0c56">More...</a><br /></td></tr>
<tr class="separator:a8c6b19fcecbd3a053016d8bc7a5b0c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf990b9c0622312257654e333c618035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html">Crout</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#abf990b9c0622312257654e333c618035">operator++</a> (int)</td></tr>
<tr class="memdesc:abf990b9c0622312257654e333c618035"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> step, suffix  <a href="#abf990b9c0622312257654e333c618035">More...</a><br /></td></tr>
<tr class="separator:abf990b9c0622312257654e333c618035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99c8fbf611e33852153c2d13ec56773"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#aa99c8fbf611e33852153c2d13ec56773">operator size_type</a> () const</td></tr>
<tr class="memdesc:aa99c8fbf611e33852153c2d13ec56773"><td class="mdescLeft">&#160;</td><td class="mdescRight">implicitly casting to size_type  <a href="#aa99c8fbf611e33852153c2d13ec56773">More...</a><br /></td></tr>
<tr class="separator:aa99c8fbf611e33852153c2d13ec56773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d792782c346ca0e8aa748e3fb13a081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a3d792782c346ca0e8aa748e3fb13a081">defers</a> () const</td></tr>
<tr class="memdesc:a3d792782c346ca0e8aa748e3fb13a081"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current defers  <a href="#a3d792782c346ca0e8aa748e3fb13a081">More...</a><br /></td></tr>
<tr class="separator:a3d792782c346ca0e8aa748e3fb13a081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b806171f0e3b1274f5e77d8fba7e73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73">deferred_step</a> () const</td></tr>
<tr class="memdesc:a48b806171f0e3b1274f5e77d8fba7e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the deferred step  <a href="#a48b806171f0e3b1274f5e77d8fba7e73">More...</a><br /></td></tr>
<tr class="separator:a48b806171f0e3b1274f5e77d8fba7e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b8b4a9c9f6e9cc01218e49c77e5d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#ae6b8b4a9c9f6e9cc01218e49c77e5d6e">increment_defer_counter</a> ()</td></tr>
<tr class="memdesc:ae6b8b4a9c9f6e9cc01218e49c77e5d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">increment the defer counter  <a href="#ae6b8b4a9c9f6e9cc01218e49c77e5d6e">More...</a><br /></td></tr>
<tr class="separator:ae6b8b4a9c9f6e9cc01218e49c77e5d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce74b5c7033230c21f25a4909ba2001"><td class="memTemplParams" colspan="2">template&lt;class ArrayType &gt; </td></tr>
<tr class="memitem:abce74b5c7033230c21f25a4909ba2001"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#abce74b5c7033230c21f25a4909ba2001">compress_array</a> (ArrayType &amp;v) const</td></tr>
<tr class="memdesc:abce74b5c7033230c21f25a4909ba2001"><td class="mdescLeft">&#160;</td><td class="mdescRight">compress an array without deferrals (gaps)  <a href="#abce74b5c7033230c21f25a4909ba2001">More...</a><br /></td></tr>
<tr class="separator:abce74b5c7033230c21f25a4909ba2001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b22f1f1e2c8025abe84d35c71fa622b"><td class="memTemplParams" colspan="2">template&lt;class ArrayIn , class ArrayOut &gt; </td></tr>
<tr class="memitem:a1b22f1f1e2c8025abe84d35c71fa622b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a1b22f1f1e2c8025abe84d35c71fa622b">assign_gap_array</a> (const ArrayIn &amp;r, ArrayOut &amp;l) const</td></tr>
<tr class="memdesc:a1b22f1f1e2c8025abe84d35c71fa622b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compress an array and assign the no-gapped value to another one  <a href="#a1b22f1f1e2c8025abe84d35c71fa622b">More...</a><br /></td></tr>
<tr class="separator:a1b22f1f1e2c8025abe84d35c71fa622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6859cbf1c747aaac7e6cbb38c33fe08"><td class="memTemplParams" colspan="2">template&lt;class ScaleArray , class CrsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class CcsType , class SpVecType &gt; </td></tr>
<tr class="memitem:ab6859cbf1c747aaac7e6cbb38c33fe08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#ab6859cbf1c747aaac7e6cbb38c33fe08">compute_ut</a> (const ScaleArray &amp;s, const CrsType &amp;crs_A, const ScaleArray &amp;t, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> pk, const PermType &amp;q, const CcsType &amp;L, const IndPtrArray &amp;L_start, const ListArray &amp;L_list, const DiagType &amp;d, const CrsType &amp;U, const IndPtrArray &amp;U_start, SpVecType &amp;ut) const</td></tr>
<tr class="memdesc:ab6859cbf1c747aaac7e6cbb38c33fe08"><td class="mdescLeft">&#160;</td><td class="mdescRight">dual of the <a class="el" href="classhif_1_1Crout.html#acd828247defa0e394b12d62811930216">compute_l</a>, i.e. computing the row of U  <a href="#ab6859cbf1c747aaac7e6cbb38c33fe08">More...</a><br /></td></tr>
<tr class="separator:ab6859cbf1c747aaac7e6cbb38c33fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd828247defa0e394b12d62811930216"><td class="memTemplParams" colspan="2">template&lt;bool IsSymm, class ScaleArray , class CcsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class CrsType , class SpVecType &gt; </td></tr>
<tr class="memitem:acd828247defa0e394b12d62811930216"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#acd828247defa0e394b12d62811930216">compute_l</a> (const ScaleArray &amp;s, const CcsType &amp;ccs_A, const ScaleArray &amp;t, const PermType &amp;p, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> qk, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> m, const CcsType &amp;L, const IndPtrArray &amp;L_start, const DiagType &amp;d, const CrsType &amp;U, const IndPtrArray &amp;U_start, const ListArray &amp;U_list, SpVecType &amp;l) const</td></tr>
<tr class="memdesc:acd828247defa0e394b12d62811930216"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the column vector of L of current step  <a href="#acd828247defa0e394b12d62811930216">More...</a><br /></td></tr>
<tr class="separator:acd828247defa0e394b12d62811930216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab428dc148a9fb48819d8ba9f104b555e"><td class="memTemplParams" colspan="2">template&lt;class ScaleArray , class CcsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class SpVecType &gt; </td></tr>
<tr class="memitem:ab428dc148a9fb48819d8ba9f104b555e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#ab428dc148a9fb48819d8ba9f104b555e">compute_symm</a> (const ScaleArray &amp;s, const CcsType &amp;ccs_A, const ScaleArray &amp;t, const PermType &amp;p, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> qk, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> m, const CcsType &amp;L, const IndPtrArray &amp;L_start, const ListArray &amp;L_list, const DiagType &amp;d, SpVecType &amp;l) const</td></tr>
<tr class="memdesc:ab428dc148a9fb48819d8ba9f104b555e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the column vector of L of current step for <img class="formulaInl" alt="$LDL^{T}$" src="form_12.png"/>  <a href="#ab428dc148a9fb48819d8ba9f104b555e">More...</a><br /></td></tr>
<tr class="separator:ab428dc148a9fb48819d8ba9f104b555e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bbf7c0a0a4c8ee89ef806e30c2bb96"><td class="memTemplParams" colspan="2">template&lt;class CsType , class ListArray , class IndPtrArray &gt; </td></tr>
<tr class="memitem:a51bbf7c0a0a4c8ee89ef806e30c2bb96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a51bbf7c0a0a4c8ee89ef806e30c2bb96">update_compress</a> (CsType &amp;T, ListArray &amp;list, IndPtrArray &amp;start) const</td></tr>
<tr class="memdesc:a51bbf7c0a0a4c8ee89ef806e30c2bb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">compress L and U and update their corresponding starting positions and linked lists  <a href="#a51bbf7c0a0a4c8ee89ef806e30c2bb96">More...</a><br /></td></tr>
<tr class="separator:a51bbf7c0a0a4c8ee89ef806e30c2bb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984d77596bff9eaabb639ce79ebf1782"><td class="memTemplParams" colspan="2">template&lt;class CcsType , class IndPtrArray &gt; </td></tr>
<tr class="memitem:a984d77596bff9eaabb639ce79ebf1782"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a984d77596bff9eaabb639ce79ebf1782">symm_update_lstart</a> (const CcsType &amp;L, const typename CcsType::size_type m, IndPtrArray &amp;L_start) const</td></tr>
<tr class="memdesc:a984d77596bff9eaabb639ce79ebf1782"><td class="mdescLeft">&#160;</td><td class="mdescRight">another starting array needed in symmetric computation to get the offsets  <a href="#a984d77596bff9eaabb639ce79ebf1782">More...</a><br /></td></tr>
<tr class="separator:a984d77596bff9eaabb639ce79ebf1782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f96d50a47d0d0dd817c3ff2b27d90f"><td class="memTemplParams" colspan="2">template&lt;class CsType , class ListArray , class IndPtrArray , class KappaArray &gt; </td></tr>
<tr class="memitem:a27f96d50a47d0d0dd817c3ff2b27d90f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a27f96d50a47d0d0dd817c3ff2b27d90f">update_kappa</a> (const CsType &amp;T, const ListArray &amp;list, const IndPtrArray &amp;start, KappaArray &amp;kappa) const</td></tr>
<tr class="memdesc:a27f96d50a47d0d0dd817c3ff2b27d90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimate the inverse norm  <a href="#a27f96d50a47d0d0dd817c3ff2b27d90f">More...</a><br /></td></tr>
<tr class="separator:a27f96d50a47d0d0dd817c3ff2b27d90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab041ed49a6b640ea60e17d52ee8bb88f"><td class="memTemplParams" colspan="2">template&lt;bool IsSymm, class SpVecType , class DiagType &gt; </td></tr>
<tr class="memitem:ab041ed49a6b640ea60e17d52ee8bb88f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!IsSymm &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#ab041ed49a6b640ea60e17d52ee8bb88f">update_diag</a> (const SpVecType &amp;l, const SpVecType &amp;ut, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> m, DiagType &amp;d) const</td></tr>
<tr class="memdesc:ab041ed49a6b640ea60e17d52ee8bb88f"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the current diagonal entry  <a href="#ab041ed49a6b640ea60e17d52ee8bb88f">More...</a><br /></td></tr>
<tr class="separator:ab041ed49a6b640ea60e17d52ee8bb88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043be0de4474ea05565263d86e3f7150"><td class="memTemplParams" colspan="2">template&lt;bool IsSymm, class SpVecType , class DiagType &gt; </td></tr>
<tr class="memitem:a043be0de4474ea05565263d86e3f7150"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; IsSymm &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a043be0de4474ea05565263d86e3f7150">update_diag</a> (const SpVecType &amp;, const SpVecType &amp;ut, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> m, DiagType &amp;d) const</td></tr>
<tr class="memdesc:a043be0de4474ea05565263d86e3f7150"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the current diagonal entry  <a href="#a043be0de4474ea05565263d86e3f7150">More...</a><br /></td></tr>
<tr class="separator:a043be0de4474ea05565263d86e3f7150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb95f423981075e44d17fe3547f8ae8"><td class="memTemplParams" colspan="2">template&lt;class DiagType , class SpVecType &gt; </td></tr>
<tr class="memitem:a6fb95f423981075e44d17fe3547f8ae8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a6fb95f423981075e44d17fe3547f8ae8">scale_inv_diag</a> (const DiagType &amp;d, SpVecType &amp;v) const</td></tr>
<tr class="memdesc:a6fb95f423981075e44d17fe3547f8ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">scale the computed row/column vectors by current diagonal inverse  <a href="#a6fb95f423981075e44d17fe3547f8ae8">More...</a><br /></td></tr>
<tr class="separator:a6fb95f423981075e44d17fe3547f8ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b356d55089463baf58948c321b70d03"><td class="memTemplParams" colspan="2">template&lt;class CsType , class IndPtrArray , class ListArray &gt; </td></tr>
<tr class="memitem:ga7b356d55089463baf58948c321b70d03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__defer.html#ga7b356d55089463baf58948c321b70d03">defer_entry</a> (const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> to_idx, const IndPtrArray &amp;start, CsType &amp;T, ListArray &amp;list) const</td></tr>
<tr class="memdesc:ga7b356d55089463baf58948c321b70d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">defer an secondary entry  <a href="group__defer.html#ga7b356d55089463baf58948c321b70d03">More...</a><br /></td></tr>
<tr class="separator:ga7b356d55089463baf58948c321b70d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35d2c5eed453173334a580cd0fc5ec19"><td class="memTemplParams" colspan="2">template&lt;class CcsType , class IndPtrArray , class ListArray &gt; </td></tr>
<tr class="memitem:ga35d2c5eed453173334a580cd0fc5ec19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__defer.html#ga35d2c5eed453173334a580cd0fc5ec19">symm_defer_l</a> (const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> to_idx, const IndPtrArray &amp;L_start, CcsType &amp;L, ListArray &amp;L_list, IndPtrArray &amp;L_offsets) const</td></tr>
<tr class="memdesc:ga35d2c5eed453173334a580cd0fc5ec19"><td class="mdescLeft">&#160;</td><td class="mdescRight">for symmetric leading block, we need to fix the offset positions while we do deferring  <a href="group__defer.html#ga35d2c5eed453173334a580cd0fc5ec19">More...</a><br /></td></tr>
<tr class="separator:ga35d2c5eed453173334a580cd0fc5ec19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4bc8ef7f02d1c684768678bbcd14f106"><td class="memTemplParams" colspan="2">template&lt;class ScaleArray , class CrsType , class PermType , class SpVecType &gt; </td></tr>
<tr class="memitem:a4bc8ef7f02d1c684768678bbcd14f106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a4bc8ef7f02d1c684768678bbcd14f106">_load_arow</a> (const ScaleArray &amp;s, const CrsType &amp;crs_A, const ScaleArray &amp;t, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> &amp;pk, const PermType &amp;q_inv, SpVecType &amp;ut) const</td></tr>
<tr class="memdesc:a4bc8ef7f02d1c684768678bbcd14f106"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a row of A to ut buffer  <a href="#a4bc8ef7f02d1c684768678bbcd14f106">More...</a><br /></td></tr>
<tr class="separator:a4bc8ef7f02d1c684768678bbcd14f106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7795707deb572dc25d6b12f9649db4db"><td class="memTemplParams" colspan="2">template&lt;bool IsSymm, class ScaleArray , class CcsType , class PermType , class SpVecType &gt; </td></tr>
<tr class="memitem:a7795707deb572dc25d6b12f9649db4db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a7795707deb572dc25d6b12f9649db4db">_load_acol</a> (const ScaleArray &amp;s, const CcsType &amp;ccs_A, const ScaleArray &amp;t, const PermType &amp;p_inv, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> &amp;qk, const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> m, SpVecType &amp;l) const</td></tr>
<tr class="memdesc:a7795707deb572dc25d6b12f9649db4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a column of A to l buffer  <a href="#a7795707deb572dc25d6b12f9649db4db">More...</a><br /></td></tr>
<tr class="separator:a7795707deb572dc25d6b12f9649db4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2de8343e54045ee80ad9e01d742ea96b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a2de8343e54045ee80ad9e01d742ea96b">_step</a></td></tr>
<tr class="memdesc:a2de8343e54045ee80ad9e01d742ea96b"><td class="mdescLeft">&#160;</td><td class="mdescRight">current step  <a href="#a2de8343e54045ee80ad9e01d742ea96b">More...</a><br /></td></tr>
<tr class="separator:a2de8343e54045ee80ad9e01d742ea96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc95f3c81de878a619a9983c8c82f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhif_1_1Crout.html#a2fc95f3c81de878a619a9983c8c82f16">_defers</a></td></tr>
<tr class="memdesc:a2fc95f3c81de878a619a9983c8c82f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">deferring counter  <a href="#a2fc95f3c81de878a619a9983c8c82f16">More...</a><br /></td></tr>
<tr class="separator:a2fc95f3c81de878a619a9983c8c82f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> update in deferred fashion</p>
<p>The idea of this class is to implement <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> kernels that wrap around a common factor&mdash;step. In this case, the class <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> is as simple (in terms of data size) as an integer. It also supports implicitly casting to integer as well as increment operations (both suffix and prefix versions). The whole disign can be demonstrate by the following C++ pseudocode: </p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classhif_1_1Crout.html#a7d4ddd7a6707f318b734410ec419c948">Crout</a> crout; crout &lt; m; ++crout) {</div><div class="line">  crout.do_work1(...);</div><div class="line">  crout.do_work2(...);</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00059">59</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a89a81b5f9cfd0ad38ce4021f4aaf8a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">hif::Crout::size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size type </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00061">61</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7d4ddd7a6707f318b734410ec419c948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4ddd7a6707f318b734410ec419c948">&#9670;&nbsp;</a></span>Crout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hif::Crout::Crout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00064">64</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>, and <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a5dd72ad4d40f88860101746811ce3176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd72ad4d40f88860101746811ce3176">&#9670;&nbsp;</a></span>Crout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hif::Crout::Crout </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="Crout_8hpp_source.html#l00084">operator++()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a5dd72ad4d40f88860101746811ce3176_icgraph.png" border="0" usemap="#classhif_1_1Crout_a5dd72ad4d40f88860101746811ce3176_icgraph" alt=""/></div>
<map name="classhif_1_1Crout_a5dd72ad4d40f88860101746811ce3176_icgraph" id="classhif_1_1Crout_a5dd72ad4d40f88860101746811ce3176_icgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#abf990b9c0622312257654e333c618035" title="increment Crout step, suffix " alt="" coords="169,5,316,32"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7795707deb572dc25d6b12f9649db4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7795707deb572dc25d6b12f9649db4db">&#9670;&nbsp;</a></span>_load_acol()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsSymm, class ScaleArray , class CcsType , class PermType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::_load_acol </td>
          <td>(</td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>ccs_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PermType &amp;&#160;</td>
          <td class="paramname"><em>p_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>qk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load a column of A to l buffer </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IsSymm</td><td>if <em>true</em>, then only load the offset </td></tr>
    <tr><td class="paramname">ScaleArray</td><td>scaling from left/right-hand sides, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CcsType</td><td>ccs matrix of input A, see <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">PermType</td><td>permutation vector type, see <a class="el" href="classhif_1_1BiPermMatrix.html">BiPermMatrix</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector type, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row scaling vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccs_A</td><td>input matrix in <a class="el" href="classhif_1_1CCS.html" title="Compressed Column Storage (CCS) format for sparse matrices. ">CCS</a> scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>column scaling vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_inv</td><td>row permutation matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qk</td><td>permuted column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>output sparse vector of column vector for A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhif_1_1Crout.html#a4bc8ef7f02d1c684768678bbcd14f106" title="load a row of A to ut buffer ">_load_arow</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00803">803</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a7795707deb572dc25d6b12f9649db4db_cgraph.png" border="0" usemap="#classhif_1_1Crout_a7795707deb572dc25d6b12f9649db4db_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_a7795707deb572dc25d6b12f9649db4db_cgraph" id="classhif_1_1Crout_a7795707deb572dc25d6b12f9649db4db_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="200,5,363,32"/>
</map>
</div>

</div>
</div>
<a id="a4bc8ef7f02d1c684768678bbcd14f106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc8ef7f02d1c684768678bbcd14f106">&#9670;&nbsp;</a></span>_load_arow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScaleArray , class CrsType , class PermType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::_load_arow </td>
          <td>(</td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CrsType &amp;&#160;</td>
          <td class="paramname"><em>crs_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> &amp;&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PermType &amp;&#160;</td>
          <td class="paramname"><em>q_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>ut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>load a row of A to ut buffer </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScaleArray</td><td>scaling from left/right-hand sides, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CrsType</td><td>crs matrix of input A, see <a class="el" href="classhif_1_1CRS.html">CRS</a> </td></tr>
    <tr><td class="paramname">PermType</td><td>permutation vector type, see <a class="el" href="classhif_1_1BiPermMatrix.html">BiPermMatrix</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector type, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row scaling vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crs_A</td><td>input matrix in <a class="el" href="classhif_1_1CRS.html" title="Compressed Row Storage (CRS) format for sparse matrices. ">CRS</a> scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>column scaling vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pk</td><td>row permuted index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_inv</td><td>column inverse permutation matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ut</td><td>output sparse vector of row vector for A </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhif_1_1Crout.html#a7795707deb572dc25d6b12f9649db4db" title="load a column of A to l buffer ">_load_acol</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00761">761</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a4bc8ef7f02d1c684768678bbcd14f106_cgraph.png" border="0" usemap="#classhif_1_1Crout_a4bc8ef7f02d1c684768678bbcd14f106_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_a4bc8ef7f02d1c684768678bbcd14f106_cgraph" id="classhif_1_1Crout_a4bc8ef7f02d1c684768678bbcd14f106_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="204,5,367,32"/>
</map>
</div>

</div>
</div>
<a id="a1b22f1f1e2c8025abe84d35c71fa622b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b22f1f1e2c8025abe84d35c71fa622b">&#9670;&nbsp;</a></span>assign_gap_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ArrayIn , class ArrayOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::assign_gap_array </td>
          <td>(</td>
          <td class="paramtype">const ArrayIn &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayOut &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compress an array and assign the no-gapped value to another one </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayIn</td><td>input array type </td></tr>
    <tr><td class="paramname">ArrayOut</td><td>output array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rhs array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>lhs array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>l[k]=r[k+d] </dd></dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00117">117</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a1b22f1f1e2c8025abe84d35c71fa622b_cgraph.png" border="0" usemap="#classhif_1_1Crout_a1b22f1f1e2c8025abe84d35c71fa622b_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_a1b22f1f1e2c8025abe84d35c71fa622b_cgraph" id="classhif_1_1Crout_a1b22f1f1e2c8025abe84d35c71fa622b_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="176,13,339,39"/>
</map>
</div>

</div>
</div>
<a id="abce74b5c7033230c21f25a4909ba2001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abce74b5c7033230c21f25a4909ba2001">&#9670;&nbsp;</a></span>compress_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::compress_array </td>
          <td>(</td>
          <td class="paramtype">ArrayType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compress an array without deferrals (gaps) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayType</td><td>in and out array type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>v[k]=v[k+d] </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00106">106</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_abce74b5c7033230c21f25a4909ba2001_cgraph.png" border="0" usemap="#classhif_1_1Crout_abce74b5c7033230c21f25a4909ba2001_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_abce74b5c7033230c21f25a4909ba2001_cgraph" id="classhif_1_1Crout_abce74b5c7033230c21f25a4909ba2001_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="195,13,357,39"/>
</map>
</div>

</div>
</div>
<a id="acd828247defa0e394b12d62811930216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd828247defa0e394b12d62811930216">&#9670;&nbsp;</a></span>compute_l()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsSymm, class ScaleArray , class CcsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class CrsType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::compute_l </td>
          <td>(</td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>ccs_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PermType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>qk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>L_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CrsType &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>U_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListArray &amp;&#160;</td>
          <td class="paramname"><em>U_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the column vector of L of current step </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IsSymm</td><td>if <em>true</em>, then a symmetric leading block is assumed </td></tr>
    <tr><td class="paramname">ScaleArray</td><td>row/column scaling diagonal matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CcsType</td><td>ccs format, see <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">PermType</td><td>permutation matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">ListArray</td><td>"linked-list" array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">DiagType</td><td>array used for storing diagonal array, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CrsType</td><td>crs format, see <a class="el" href="classhif_1_1CRS.html">CRS</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector for storing l, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row scaling matrix from preprocessing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccs_A</td><td>input matrix in ccs scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>column scaling matrix from preprocessing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>row inverse permutation matrix (deferred) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qk</td><td>permutated column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading block size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>lower part of decomposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L_start</td><td>"linked-list" array storing the starting locations of <em>L</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>diagonal entries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>augmented U matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_start</td><td>starting positions of U </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_list</td><td>linked list of row indices of current step in U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>column vector of L at current <a class="el" href="classhif_1_1Crout.html#a2de8343e54045ee80ad9e01d742ea96b">_step</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhif_1_1Crout.html#ab6859cbf1c747aaac7e6cbb38c33fe08" title="dual of the compute_l, i.e. computing the row of U ">compute_ut</a></dd></dl>
<p>This routine computes the current column vector of <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> (w/o diagonal scaling). Mathematically, this routine is to compute:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{\ell}_{k}= \hat{\mathbf{A}}[\mathbf{p}_{k+1:n},q_{k}]- \mathbf{L}_{k+1:n,1:k-1}\mathbf{D}_{k-1} \mathbf{U}_{1:k-1,k} \]" src="form_7.png"/>
</p>
<p>It's worth noting that, conceptally, the formula above is nothing but a matrix vector operation. However, standard implementation won't give good performance (especially with consideration of cache performance), this is because <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> is stored in column major whereas row major for <img class="formulaInl" alt="$\mathbf{U}$" src="form_0.png"/>. Therefore, the actual implementation is in the fashion that loops through <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> in column major while keeping <img class="formulaInl" alt="$\mathbf{U}$" src="form_0.png"/> as much static as possible.</p>
<p>Regarding the complexity cost, it takes <img class="formulaInl" alt="$\mathcal{O}(\textrm{nnz}(\mathbf{A}_{:,q_k}))$" src="form_8.png"/> to first load the column of A to <img class="formulaInl" alt="$\mathbf{\ell}_k$" src="form_9.png"/>, and takes <img class="formulaInl" alt="$\mathcal{O}(\cup_i \textrm{nnz}(\mathbf{L}_{:,i}))$" src="form_10.png"/>, where <img class="formulaInl" alt="$u_{ik}\neq 0$" src="form_11.png"/> for computing the matrix vector operation. </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00271">271</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>, <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_acd828247defa0e394b12d62811930216_cgraph.png" border="0" usemap="#classhif_1_1Crout_acd828247defa0e394b12d62811930216_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_acd828247defa0e394b12d62811930216_cgraph" id="classhif_1_1Crout_acd828247defa0e394b12d62811930216_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="197,5,360,32"/>
</map>
</div>

</div>
</div>
<a id="ab428dc148a9fb48819d8ba9f104b555e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab428dc148a9fb48819d8ba9f104b555e">&#9670;&nbsp;</a></span>compute_symm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScaleArray , class CcsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::compute_symm </td>
          <td>(</td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>ccs_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PermType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>qk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>L_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListArray &amp;&#160;</td>
          <td class="paramname"><em>L_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the column vector of L of current step for <img class="formulaInl" alt="$LDL^{T}$" src="form_12.png"/> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScaleArray</td><td>row/column scaling diagonal matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CcsType</td><td>ccs format, see <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">PermType</td><td>permutation matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">ListArray</td><td>"linked-list" array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">DiagType</td><td>array used for storing diagonal array, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector for storing l, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row scaling matrix from preprocessing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccs_A</td><td>input matrix in ccs scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>column scaling matrix from preprocessing, should be <em>s</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>row inverse permutation matrix (deferred) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qk</td><td>permutated column index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading block size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>lower part of decomposition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L_start</td><td>position array storing the starting locations of <em>L</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L_list</td><td>linked list of row indices of current step in <em>L</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>diagonal entries </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>column vector of L at current <a class="el" href="classhif_1_1Crout.html#a2de8343e54045ee80ad9e01d742ea96b">_step</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhif_1_1Crout.html#ab6859cbf1c747aaac7e6cbb38c33fe08" title="dual of the compute_l, i.e. computing the row of U ">compute_ut</a></dd></dl>
<p>This routine computes the current column vector of <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> (w/o diagonal scaling). Mathematically, this routine is to compute:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{\ell}_{k}= \hat{\mathbf{A}}[\mathbf{p}_{k+1:n},q_{k}]- \mathbf{L}_{k+1:n,1:k-1}\mathbf{D}_{k-1} \mathbf{L}_{k,1:k-1}^{T} \]" src="form_13.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00359">359</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_ab428dc148a9fb48819d8ba9f104b555e_cgraph.png" border="0" usemap="#classhif_1_1Crout_ab428dc148a9fb48819d8ba9f104b555e_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_ab428dc148a9fb48819d8ba9f104b555e_cgraph" id="classhif_1_1Crout_ab428dc148a9fb48819d8ba9f104b555e_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="231,5,393,32"/>
</map>
</div>

</div>
</div>
<a id="ab6859cbf1c747aaac7e6cbb38c33fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6859cbf1c747aaac7e6cbb38c33fe08">&#9670;&nbsp;</a></span>compute_ut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ScaleArray , class CrsType , class PermType , class ListArray , class IndPtrArray , class DiagType , class CcsType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::compute_ut </td>
          <td>(</td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CrsType &amp;&#160;</td>
          <td class="paramname"><em>crs_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScaleArray &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>pk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PermType &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>L_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListArray &amp;&#160;</td>
          <td class="paramname"><em>L_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CrsType &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>U_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>ut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dual of the <a class="el" href="classhif_1_1Crout.html#acd828247defa0e394b12d62811930216">compute_l</a>, i.e. computing the row of U </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ScaleArray</td><td>row scaling diagonal matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CrsType</td><td>crs format, see <a class="el" href="classhif_1_1CRS.html">CRS</a> </td></tr>
    <tr><td class="paramname">PermType</td><td>permutation matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">ListArray</td><td>"linked-list" array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">DiagType</td><td>diagonal matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">CcsType</td><td>ccs format, see <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>work array for current row vector, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row scaling matrix from preprocessing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">crs_A</td><td>input matrix in crs scheme </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>column scaling matrix from preprocessing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pk</td><td>permutated row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>column inverse permutation (deferred) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>lower part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L_start</td><td>starting positions for current step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L_list</td><td>linked list of column indices for current step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>diagonal vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>upper part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U_start</td><td>leading row positions of current <a class="el" href="classhif_1_1Crout.html#a2de8343e54045ee80ad9e01d742ea96b">_step</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ut</td><td>current row vector of U </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classhif_1_1Crout.html#acd828247defa0e394b12d62811930216" title="compute the column vector of L of current step ">compute_l</a></dd></dl>
<p>This routine computes the current row vector of <img class="formulaInl" alt="$\mathbf{U}$" src="form_0.png"/> (w/o diagonal scaling). Mathematically, this routine is to compute:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{u}_{k}^{T}= \hat{\mathbf{A}}[p_{k},\mathbf{q}_{k+1:n}]- \mathbf{L}_{k,1:k-1}\mathbf{D}_{k-1} \mathbf{U}_{1:k-1,k+1:n} \]" src="form_1.png"/>
</p>
<p>It's worth noting that, conceptally, the formula above is nothing but a vector matrix operation. However, standard implementation won't give good performance (especially with consideration of cache performance), this is because <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> is stored in column major whereas row major for <img class="formulaInl" alt="$\mathbf{U}$" src="form_0.png"/>. Therefore, the actual implementation is in the fashion that loops through <img class="formulaInl" alt="$\mathbf{U}$" src="form_0.png"/> in row major while keeping <img class="formulaInl" alt="$\mathbf{L}$" src="form_2.png"/> as much static as possible.</p>
<p>Regarding the complexity cost, it takes <img class="formulaInl" alt="$\mathcal{O}(\textrm{nnz}(\mathbf{A}_{p_k,:}))$" src="form_3.png"/> to first load the row of A to <img class="formulaInl" alt="$\mathbf{u}_k^T$" src="form_4.png"/>, and takes <img class="formulaInl" alt="$\mathcal{O}(\cup_j \textrm{nnz}(\mathbf{U}_{j,:}))$" src="form_5.png"/>, where <img class="formulaInl" alt="$l_{kj}\neq 0$" src="form_6.png"/> for computing the vector matrix operation. </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00169">169</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_ab6859cbf1c747aaac7e6cbb38c33fe08_cgraph.png" border="0" usemap="#classhif_1_1Crout_ab6859cbf1c747aaac7e6cbb38c33fe08_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_ab6859cbf1c747aaac7e6cbb38c33fe08_cgraph" id="classhif_1_1Crout_ab6859cbf1c747aaac7e6cbb38c33fe08_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="205,5,368,32"/>
</map>
</div>

</div>
</div>
<a id="a48b806171f0e3b1274f5e77d8fba7e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b806171f0e3b1274f5e77d8fba7e73">&#9670;&nbsp;</a></span>deferred_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> hif::Crout::deferred_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the deferred step </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00097">97</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>, and <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

<p class="reference">Referenced by <a class="el" href="Crout_8hpp_source.html#l00803">_load_acol()</a>, <a class="el" href="Crout_8hpp_source.html#l00761">_load_arow()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00510">hif::PivotCrout::apply_thres_pivot()</a>, <a class="el" href="Crout_8hpp_source.html#l00117">assign_gap_array()</a>, <a class="el" href="Crout_8hpp_source.html#l00106">compress_array()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00093">hif::PivotCrout::compute_dk()</a>, <a class="el" href="Crout_8hpp_source.html#l00271">compute_l()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00298">hif::PivotCrout::compute_l()</a>, <a class="el" href="Crout_8hpp_source.html#l00359">compute_symm()</a>, <a class="el" href="Crout_8hpp_source.html#l00169">compute_ut()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00195">hif::PivotCrout::compute_ut()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00435">hif::PivotCrout::defer_entry()</a>, <a class="el" href="Crout_8hpp_source.html#l00681">defer_entry()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00454">hif::PivotCrout::interchange()</a>, <a class="el" href="factor_8hpp_source.html#l00553">hif::level_factorize()</a>, <a class="el" href="pivot__factor_8hpp_source.html#l00065">hif::pivot_level_factorize()</a>, <a class="el" href="Crout_8hpp_source.html#l00721">symm_defer_l()</a>, <a class="el" href="symm__factor_8hpp_source.html#l00126">hif::symm_level_factorize()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00362">hif::PivotCrout::update_compress()</a>, <a class="el" href="Crout_8hpp_source.html#l00428">update_compress()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00394">hif::PivotCrout::update_kappa()</a>, and <a class="el" href="Crout_8hpp_source.html#l00486">update_kappa()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a48b806171f0e3b1274f5e77d8fba7e73_icgraph.png" border="0" usemap="#classhif_1_1Crout_a48b806171f0e3b1274f5e77d8fba7e73_icgraph" alt=""/></div>
<map name="classhif_1_1Crout_a48b806171f0e3b1274f5e77d8fba7e73_icgraph" id="classhif_1_1Crout_a48b806171f0e3b1274f5e77d8fba7e73_icgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a7795707deb572dc25d6b12f9649db4db" title="load a column of A to l buffer " alt="" coords="235,5,382,32"/>
<area shape="rect" id="node3" href="classhif_1_1Crout.html#a4bc8ef7f02d1c684768678bbcd14f106" title="load a row of A to ut buffer " alt="" coords="233,56,384,83"/>
<area shape="rect" id="node4" href="classhif_1_1PivotCrout.html#a67ee6d3984898a8fac1f38c0f98c2e26" title="Apply inverse&#45;based rook pivoting. " alt="" coords="236,107,381,149"/>
<area shape="rect" id="node5" href="classhif_1_1Crout.html#a1b22f1f1e2c8025abe84d35c71fa622b" title="compress an array and assign the no&#45;gapped value to another one " alt="" coords="247,173,370,214"/>
<area shape="rect" id="node6" href="classhif_1_1Crout.html#abce74b5c7033230c21f25a4909ba2001" title="compress an array without deferrals (gaps) " alt="" coords="238,238,379,279"/>
<area shape="rect" id="node7" href="classhif_1_1PivotCrout.html#a07090b1b1076f6c100df45ec3952226e" title="compute diagonal entry " alt="" coords="216,304,401,331"/>
<area shape="rect" id="node8" href="classhif_1_1Crout.html#acd828247defa0e394b12d62811930216" title="compute the column vector of L of current step " alt="" coords="237,355,381,381"/>
<area shape="rect" id="node9" href="classhif_1_1PivotCrout.html#a10f12a87c293233a0acd52ece0a41c4f" title="compute the column vector of L of current step " alt="" coords="221,405,396,432"/>
<area shape="rect" id="node10" href="classhif_1_1Crout.html#ab428dc148a9fb48819d8ba9f104b555e" title="compute the column vector of L of current step for &#160;" alt="" coords="220,456,397,483"/>
<area shape="rect" id="node11" href="classhif_1_1Crout.html#ab6859cbf1c747aaac7e6cbb38c33fe08" title="dual of the compute_l, i.e. computing the row of U " alt="" coords="233,507,385,533"/>
<area shape="rect" id="node12" href="classhif_1_1PivotCrout.html#a82761654d2ad8824de83e7073aa64629" title="dual of the compute_l, i.e. computing the row of U " alt="" coords="217,557,400,584"/>
<area shape="rect" id="node13" href="group__defer.html#ga3de53a81bcc7cfdc4a70f5fe7cc20743" title="defer an secondary entry, i.e., rows in CCS and columns in CRS " alt="" coords="237,609,380,650"/>
<area shape="rect" id="node14" href="group__defer.html#ga7b356d55089463baf58948c321b70d03" title="defer an secondary entry " alt="" coords="234,675,383,701"/>
<area shape="rect" id="node15" href="classhif_1_1PivotCrout.html#a75f24ca9e1bcfa66268de9b280c58536" title="interchagen with pivot for pivoting with Crout LU " alt="" coords="218,725,399,752"/>
<area shape="rect" id="node16" href="group__fac.html#ga5e85c4efc549f28f913faacc7a901d9b" title="perform partial incomplete LU for a level " alt="" coords="245,776,373,803"/>
<area shape="rect" id="node17" href="group__fac.html#gacf606dfc70540b8eff78f1e1102e7529" title="perform partial incomplete LU for a level with thresholding pivoting " alt="" coords="227,827,390,853"/>
<area shape="rect" id="node18" href="group__defer.html#ga35d2c5eed453173334a580cd0fc5ec19" title="for symmetric leading block, we need to fix the offset positions while we do deferring ..." alt="" coords="225,877,392,904"/>
<area shape="rect" id="node19" href="group__fac.html#ga7f72580db4c9b6183bafd84427b8c17d" title="perform partial incomplete LU for a level " alt="" coords="223,928,394,955"/>
<area shape="rect" id="node20" href="classhif_1_1PivotCrout.html#ae76c701d74e4e9d77f2acf23fcecb6cc" title="compress L and U and update their corresponding starting positions " alt="" coords="232,979,385,1021"/>
<area shape="rect" id="node21" href="classhif_1_1Crout.html#a51bbf7c0a0a4c8ee89ef806e30c2bb96" title="compress L and U and update their corresponding starting positions and linked lists ..." alt="" coords="247,1045,370,1086"/>
<area shape="rect" id="node22" href="classhif_1_1PivotCrout.html#a0a5d451bf8f68a3d76805b7b291511ca" title="estimate the inverse norm with augmented ds " alt="" coords="232,1110,385,1151"/>
<area shape="rect" id="node23" href="classhif_1_1Crout.html#a27f96d50a47d0d0dd817c3ff2b27d90f" title="estimate the inverse norm " alt="" coords="247,1175,370,1217"/>
</map>
</div>

</div>
</div>
<a id="a3d792782c346ca0e8aa748e3fb13a081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d792782c346ca0e8aa748e3fb13a081">&#9670;&nbsp;</a></span>defers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> hif::Crout::defers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the current defers </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00094">94</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>.</p>

<p class="reference">Referenced by <a class="el" href="factor_8hpp_source.html#l00553">hif::level_factorize()</a>, <a class="el" href="pivot__factor_8hpp_source.html#l00065">hif::pivot_level_factorize()</a>, and <a class="el" href="symm__factor_8hpp_source.html#l00126">hif::symm_level_factorize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a3d792782c346ca0e8aa748e3fb13a081_icgraph.png" border="0" usemap="#classhif_1_1Crout_a3d792782c346ca0e8aa748e3fb13a081_icgraph" alt=""/></div>
<map name="classhif_1_1Crout_a3d792782c346ca0e8aa748e3fb13a081_icgraph" id="classhif_1_1Crout_a3d792782c346ca0e8aa748e3fb13a081_icgraph">
<area shape="rect" id="node2" href="group__fac.html#ga5e85c4efc549f28f913faacc7a901d9b" title="perform partial incomplete LU for a level " alt="" coords="195,5,323,32"/>
<area shape="rect" id="node3" href="group__fac.html#gacf606dfc70540b8eff78f1e1102e7529" title="perform partial incomplete LU for a level with thresholding pivoting " alt="" coords="177,56,340,83"/>
<area shape="rect" id="node4" href="group__fac.html#ga7f72580db4c9b6183bafd84427b8c17d" title="perform partial incomplete LU for a level " alt="" coords="173,107,344,133"/>
</map>
</div>

</div>
</div>
<a id="ae6b8b4a9c9f6e9cc01218e49c77e5d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b8b4a9c9f6e9cc01218e49c77e5d6e">&#9670;&nbsp;</a></span>increment_defer_counter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::increment_defer_counter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment the defer counter </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00100">100</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>.</p>

<p class="reference">Referenced by <a class="el" href="factor_8hpp_source.html#l00553">hif::level_factorize()</a>, <a class="el" href="pivot__factor_8hpp_source.html#l00065">hif::pivot_level_factorize()</a>, and <a class="el" href="symm__factor_8hpp_source.html#l00126">hif::symm_level_factorize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_ae6b8b4a9c9f6e9cc01218e49c77e5d6e_icgraph.png" border="0" usemap="#classhif_1_1Crout_ae6b8b4a9c9f6e9cc01218e49c77e5d6e_icgraph" alt=""/></div>
<map name="classhif_1_1Crout_ae6b8b4a9c9f6e9cc01218e49c77e5d6e_icgraph" id="classhif_1_1Crout_ae6b8b4a9c9f6e9cc01218e49c77e5d6e_icgraph">
<area shape="rect" id="node2" href="group__fac.html#ga5e85c4efc549f28f913faacc7a901d9b" title="perform partial incomplete LU for a level " alt="" coords="216,5,344,32"/>
<area shape="rect" id="node3" href="group__fac.html#gacf606dfc70540b8eff78f1e1102e7529" title="perform partial incomplete LU for a level with thresholding pivoting " alt="" coords="199,56,361,83"/>
<area shape="rect" id="node4" href="group__fac.html#ga7f72580db4c9b6183bafd84427b8c17d" title="perform partial incomplete LU for a level " alt="" coords="195,107,365,133"/>
</map>
</div>

</div>
</div>
<a id="aa99c8fbf611e33852153c2d13ec56773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99c8fbf611e33852153c2d13ec56773">&#9670;&nbsp;</a></span>operator size_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hif::Crout::operator <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>implicitly casting to size_type </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00091">91</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a8c6b19fcecbd3a053016d8bc7a5b0c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6b19fcecbd3a053016d8bc7a5b0c56">&#9670;&nbsp;</a></span>operator++() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhif_1_1Crout.html">Crout</a>&amp; hif::Crout::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> step </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00078">78</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

<p class="reference">Referenced by <a class="el" href="factor_8hpp_source.html#l00553">hif::level_factorize()</a>, <a class="el" href="pivot__factor_8hpp_source.html#l00065">hif::pivot_level_factorize()</a>, and <a class="el" href="symm__factor_8hpp_source.html#l00126">hif::symm_level_factorize()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a8c6b19fcecbd3a053016d8bc7a5b0c56_icgraph.png" border="0" usemap="#classhif_1_1Crout_a8c6b19fcecbd3a053016d8bc7a5b0c56_icgraph" alt=""/></div>
<map name="classhif_1_1Crout_a8c6b19fcecbd3a053016d8bc7a5b0c56_icgraph" id="classhif_1_1Crout_a8c6b19fcecbd3a053016d8bc7a5b0c56_icgraph">
<area shape="rect" id="node2" href="group__fac.html#ga5e85c4efc549f28f913faacc7a901d9b" title="perform partial incomplete LU for a level " alt="" coords="221,5,349,32"/>
<area shape="rect" id="node3" href="group__fac.html#gacf606dfc70540b8eff78f1e1102e7529" title="perform partial incomplete LU for a level with thresholding pivoting " alt="" coords="204,56,367,83"/>
<area shape="rect" id="node4" href="group__fac.html#ga7f72580db4c9b6183bafd84427b8c17d" title="perform partial incomplete LU for a level " alt="" coords="200,107,371,133"/>
</map>
</div>

</div>
</div>
<a id="abf990b9c0622312257654e333c618035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf990b9c0622312257654e333c618035">&#9670;&nbsp;</a></span>operator++() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html">Crout</a> hif::Crout::operator++ </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>increment <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> step, suffix </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00084">84</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="classhif_1_1Crout.html#a5dd72ad4d40f88860101746811ce3176">Crout()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_abf990b9c0622312257654e333c618035_cgraph.png" border="0" usemap="#classhif_1_1Crout_abf990b9c0622312257654e333c618035_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_abf990b9c0622312257654e333c618035_cgraph" id="classhif_1_1Crout_abf990b9c0622312257654e333c618035_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a5dd72ad4d40f88860101746811ce3176" title="hif::Crout::Crout" alt="" coords="200,5,316,32"/>
</map>
</div>

</div>
</div>
<a id="a5b517a206e7b25fb510cc6565e18706f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b517a206e7b25fb510cc6565e18706f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html">Crout</a>&amp; hif::Crout::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html">Crout</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e22ec45a6def489e94b478f999654c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e22ec45a6def489e94b478f999654c4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html">Crout</a>&amp; hif::Crout::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign to a step </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00072">72</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a6fb95f423981075e44d17fe3547f8ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb95f423981075e44d17fe3547f8ae8">&#9670;&nbsp;</a></span>scale_inv_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DiagType , class SpVecType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hif::Crout::scale_inv_diag </td>
          <td>(</td>
          <td class="paramtype">const DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpVecType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>scale the computed row/column vectors by current diagonal inverse </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DiagType</td><td>diagonal matrix type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector for storing l/U, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>diagonal vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">v</td><td>vector to be scaled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The returned boolean flag indices a singularity occurs if <em>true</em> </dd></dl>
<p>This routine computes <img class="formulaInl" alt="$\mathbf{v}=\mathbf{v}/d_k$" src="form_17.png"/>; firstly, singularity is checked to ensure the validation of computation. Then, we test if it's safe to invert <img class="formulaInl" alt="$d_k$" src="form_18.png"/> so that we can use multiplication instead of division.</p>
<p>Regarding complexity, this routine takes <img class="formulaInl" alt="$\mathcal{O}(\textrm{nnz}(\mathbf{v}))$" src="form_19.png"/> </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00647">647</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a984d77596bff9eaabb639ce79ebf1782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984d77596bff9eaabb639ce79ebf1782">&#9670;&nbsp;</a></span>symm_update_lstart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CcsType , class IndPtrArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::symm_update_lstart </td>
          <td>(</td>
          <td class="paramtype">const CcsType &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename CcsType::size_type&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>L_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>another starting array needed in symmetric computation to get the offsets </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CcsType</td><td>ccs type for L, see <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>lower factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading block size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L_start</td><td>offset starting positions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00467">467</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a51bbf7c0a0a4c8ee89ef806e30c2bb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bbf7c0a0a4c8ee89ef806e30c2bb96">&#9670;&nbsp;</a></span>update_compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CsType , class ListArray , class IndPtrArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hif::Crout::update_compress </td>
          <td>(</td>
          <td class="paramtype">CsType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListArray &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compress L and U and update their corresponding starting positions and linked lists </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CsType</td><td>either <a class="el" href="classhif_1_1CRS.html">CRS</a> or <a class="el" href="classhif_1_1CCS.html">CCS</a> </td></tr>
    <tr><td class="paramname">ListArray</td><td>"linked-list" array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">T</td><td>strictly lower (L) or upper (U) matrices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">list</td><td>linked list of current step with primary indices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td>local positions</td></tr>
  </table>
  </dd>
</dl>
<p>The overall idea involves the following steps: (1) loop through the current secondary axis to get the primary indices in <em>list</em>, then (2) from these primary indices combining with starting positions, <em>start</em>, to get the index and value arrays position, (3) next step is to compress the index wrt to the current overall deferals, finally (4) advance the starting position and update the linked list accordingly.</p>
<p>Clearly, all these steps must be done concurrently with in a single loop. </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00428">428</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00833">_defers</a>, <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a51bbf7c0a0a4c8ee89ef806e30c2bb96_cgraph.png" border="0" usemap="#classhif_1_1Crout_a51bbf7c0a0a4c8ee89ef806e30c2bb96_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_a51bbf7c0a0a4c8ee89ef806e30c2bb96_cgraph" id="classhif_1_1Crout_a51bbf7c0a0a4c8ee89ef806e30c2bb96_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="176,13,339,39"/>
</map>
</div>

</div>
</div>
<a id="ab041ed49a6b640ea60e17d52ee8bb88f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab041ed49a6b640ea60e17d52ee8bb88f">&#9670;&nbsp;</a></span>update_diag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsSymm, class SpVecType , class DiagType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!IsSymm&gt;::type hif::Crout::update_diag </td>
          <td>(</td>
          <td class="paramtype">const SpVecType &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpVecType &amp;&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update the current diagonal entry </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IsSymm</td><td>if <em>true</em>, then assuming we have a leading block </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector for storing l/U, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
    <tr><td class="paramname">DiagType</td><td>diagonal vector array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>newly computed column vector of L </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ut</td><td>newly computed row vector of U </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading block size (not necessary for symmetric) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>diagonal vector</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is <em>SFINAE-able</em> by <em>IsSymm</em> and it's for asymmetric cases. This routine is to compute the last step in <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> updates, i.e. updating the diagonal entries:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{D}_{k+1:m,k+1:m}=\mathbf{D}_{k+1:m,k+1:m}- \mathbf{D}_{k,k} \left(\mathbf{\ell}_k\otimes\mathbf{u}_k\right)_{k+1:m,k+1:m} \]" src="form_14.png"/>
</p>
<p>The complexity is bounded by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{O}(\min(\textrm{nnz}(\mathbf{\ell}_k), \textrm{nnz}(\mathbf{u}_k))) \]" src="form_15.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00543">543</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a043be0de4474ea05565263d86e3f7150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043be0de4474ea05565263d86e3f7150">&#9670;&nbsp;</a></span>update_diag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsSymm, class SpVecType , class DiagType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;IsSymm&gt;::type hif::Crout::update_diag </td>
          <td>(</td>
          <td class="paramtype">const SpVecType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SpVecType &amp;&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiagType &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update the current diagonal entry </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IsSymm</td><td>if <em>true</em>, then assuming we have a leading block </td></tr>
    <tr><td class="paramname">SpVecType</td><td>sparse vector for storing l, see <a class="el" href="classhif_1_1SparseVector.html">SparseVector</a> </td></tr>
    <tr><td class="paramname">DiagType</td><td>diagonal vector array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ut</td><td>newly computed row vector of U </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>leading block size (not necessary for symmetric) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>diagonal vector</td></tr>
  </table>
  </dd>
</dl>
<p>This routine is <em>SFINAE-able</em> by <em>IsSymm</em> and it's for symmetric cases. This routine is to compute the last step in <a class="el" href="classhif_1_1Crout.html" title="Crout update in deferred fashionThe idea of this class is to implement Crout kernels that wrap around...">Crout</a> updates, i.e. updating the diagonal entries:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathbf{D}_{k+1:m,k+1:m}=\mathbf{D}_{k+1:m,k+1:m}- \mathbf{D}_{k,k} \left(\mathbf{\ell}_k\otimes\mathbf{u}_k\right)_{k+1:m,k+1:m} \]" src="form_14.png"/>
</p>
<p>The complexity is bounded by:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathcal{O}(\textrm{nnz}(\mathbf{u}_k)) \]" src="form_16.png"/>
</p>
 
<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00614">614</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>.</p>

</div>
</div>
<a id="a27f96d50a47d0d0dd817c3ff2b27d90f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f96d50a47d0d0dd817c3ff2b27d90f">&#9670;&nbsp;</a></span>update_kappa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CsType , class ListArray , class IndPtrArray , class KappaArray &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hif::Crout::update_kappa </td>
          <td>(</td>
          <td class="paramtype">const CsType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ListArray &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndPtrArray &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KappaArray &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>estimate the inverse norm </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CsType</td><td>either <a class="el" href="classhif_1_1CRS.html">CRS</a> (U) or <a class="el" href="classhif_1_1CCS.html">CCS</a> (L) </td></tr>
    <tr><td class="paramname">ListArray</td><td>"linked-list" array type, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
    <tr><td class="paramname">IndPtrArray</td><td>index pointer array </td></tr>
    <tr><td class="paramname">KappaArray</td><td>array type for storing inverse norms, see <a class="el" href="classhif_1_1Array.html">Array</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>lower or upper factors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">list</td><td>linked list of primary indices of current step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>starting positions in index and value arrays </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">kappa</td><td>inverse norm solutions </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00486">486</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">References <a class="el" href="Crout_8hpp_source.html#l00832">_step</a>, and <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classhif_1_1Crout_a27f96d50a47d0d0dd817c3ff2b27d90f_cgraph.png" border="0" usemap="#classhif_1_1Crout_a27f96d50a47d0d0dd817c3ff2b27d90f_cgraph" alt=""/></div>
<map name="classhif_1_1Crout_a27f96d50a47d0d0dd817c3ff2b27d90f_cgraph" id="classhif_1_1Crout_a27f96d50a47d0d0dd817c3ff2b27d90f_cgraph">
<area shape="rect" id="node2" href="classhif_1_1Crout.html#a48b806171f0e3b1274f5e77d8fba7e73" title="get the deferred step " alt="" coords="176,13,339,39"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2fc95f3c81de878a619a9983c8c82f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc95f3c81de878a619a9983c8c82f16">&#9670;&nbsp;</a></span>_defers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> hif::Crout::_defers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deferring counter </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00833">833</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PivotCrout_8hpp_source.html#l00510">hif::PivotCrout::apply_thres_pivot()</a>, <a class="el" href="Crout_8hpp_source.html#l00271">compute_l()</a>, <a class="el" href="Crout_8hpp_source.html#l00064">Crout()</a>, <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>, <a class="el" href="Crout_8hpp_source.html#l00094">defers()</a>, <a class="el" href="Crout_8hpp_source.html#l00100">increment_defer_counter()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00362">hif::PivotCrout::update_compress()</a>, and <a class="el" href="Crout_8hpp_source.html#l00428">update_compress()</a>.</p>

</div>
</div>
<a id="a2de8343e54045ee80ad9e01d742ea96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2de8343e54045ee80ad9e01d742ea96b">&#9670;&nbsp;</a></span>_step</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhif_1_1Crout.html#a89a81b5f9cfd0ad38ce4021f4aaf8a4c">size_type</a> hif::Crout::_step</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>current step </p>

<p class="definition">Definition at line <a class="el" href="Crout_8hpp_source.html#l00832">832</a> of file <a class="el" href="Crout_8hpp_source.html">Crout.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Crout_8hpp_source.html#l00803">_load_acol()</a>, <a class="el" href="Crout_8hpp_source.html#l00761">_load_arow()</a>, <a class="el" href="Crout_8hpp_source.html#l00117">assign_gap_array()</a>, <a class="el" href="Crout_8hpp_source.html#l00106">compress_array()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00093">hif::PivotCrout::compute_dk()</a>, <a class="el" href="Crout_8hpp_source.html#l00271">compute_l()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00298">hif::PivotCrout::compute_l()</a>, <a class="el" href="Crout_8hpp_source.html#l00359">compute_symm()</a>, <a class="el" href="Crout_8hpp_source.html#l00169">compute_ut()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00195">hif::PivotCrout::compute_ut()</a>, <a class="el" href="Crout_8hpp_source.html#l00064">Crout()</a>, <a class="el" href="Crout_8hpp_source.html#l00681">defer_entry()</a>, <a class="el" href="Crout_8hpp_source.html#l00097">deferred_step()</a>, <a class="el" href="Crout_8hpp_source.html#l00091">operator size_type()</a>, <a class="el" href="Crout_8hpp_source.html#l00078">operator++()</a>, <a class="el" href="Crout_8hpp_source.html#l00072">operator=()</a>, <a class="el" href="Crout_8hpp_source.html#l00647">scale_inv_diag()</a>, <a class="el" href="Crout_8hpp_source.html#l00721">symm_defer_l()</a>, <a class="el" href="Crout_8hpp_source.html#l00467">symm_update_lstart()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00362">hif::PivotCrout::update_compress()</a>, <a class="el" href="Crout_8hpp_source.html#l00428">update_compress()</a>, <a class="el" href="Crout_8hpp_source.html#l00543">update_diag()</a>, <a class="el" href="PivotCrout_8hpp_source.html#l00394">hif::PivotCrout::update_kappa()</a>, and <a class="el" href="Crout_8hpp_source.html#l00486">update_kappa()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Crout_8hpp_source.html">Crout.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacehif.html">hif</a></li><li class="navelem"><a class="el" href="classhif_1_1Crout.html">Crout</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
